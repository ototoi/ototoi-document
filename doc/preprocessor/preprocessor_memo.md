#Cプリプロセッサ動作メモ

##本文書について
Cプリプロセッサ動作を個人的メモを記述するものである。

##参考資料
- "C++でCプリプロセッサを作ったり速くしたりしたお話" http://www.slideshare.net/kinukox/cc-55863339
- "Dave Prosser's C Preprocessing Algorithm" http://www.spinellis.gr/blog/20060626/

##コメントは削除されるのか？
- デフォルトではコメントは削除される。
- オプションでコメントを削除しないモードが存在する。
  - gccでは`-C`を付ける。`gcc -E -C target.c`

##マクロ名として許されるのは？
- マクロ名はCの識別子によって構成される。
  - 最初の一文字目は`アルファベット`か`_`、２文字目以降は`アルファベット`か`_`か`数字`
  - `([a-zA-Z]|_)+([a-zA-Z]|_|[0-9])*`
- マクロ名にCの識別子以外の名前をつけようとするとエラー
```
#define 1M(x) x  //エラー
#define M2(x) x  //正しい
#define _M3(x) x  //正しい
#define +M4(x) x  //エラー
```

##マクロの再定義
- マクロは同じ名前で再定義すると、警告をだすが再定義可能
- マクロの再定義で、警告を出さないモードが存在
  -  gccでは`-Wmacro-redefined`を付ける。`gcc -E -Wmacro-redefined target.c`

##マクロはいつ展開されるのか
- ディレクティブ行は展開されない
  - あらかじめ展開するなどしない（実際に使用されるまで再定義される可能性があるため） 
- コメント中は展開されない

```
#define M1(x) x  
#define M2(x) M1(x)       //この時点では展開されない:#xではない
#define M1(x) #x          //再定義 

M1(1);        //展開される:"1";
//M1(1);      //展開されない://M1(1);
/*M1(1);*/    //展開されない:/*M1(1);*/
```

##マクロの再帰はされるのか
- マクロ展開は自己再帰展開されない
  - 一度展開されたマクロは再帰的にマクロを展開する際、HS(Hide Set)に登録される。
```
#define M1(x) M3(x)   //
#define M2(x) M1(x)   //
#define M3(x) M2(x)   //
#define M4(x) M3(x)   //

M3(1);                //M3(1); 
M3(1);                //M3(1);
M4(1);                //M3(1);M4を展開するとき、M3を展開したためM1にてM3が展開されない
```
  
##`#`による文字列化
- `#`を関数マクロの定義部の変数の前につけるとその変数の中身を文字列化する。
- `#`を関数マクロの定義部の変数以外につけるとエラーとなる。
```
#define M1(x) #x     //正しい
#define M2(#x) x     //エラー：宣言部の変数に#をつけている
#define M3(x) x #2   //エラー：定義部の変数以外に#をつけている

int main(){
    printf(#1);   //エラー：関数マクロ以外に#をつけている
    return 0;
}
```

##`#`による文字列化はいつ動作するか
- マクロ展開中に`#`による文字列化が起こる
- 文字列化 > トークン結合 > マクロ展開の順

```
#define M1(x) 1     
#define M2(x) #x     

M2(M1(1))         //"M1(1)" : "1"ではない
```

##`##`によるトークン結合
- マクロの定義部で記述可能

```
#define M1(x) x ## 1    //成功:x1
#define M2(x) M ## 1(x)    //成功:x1
#define M3(x ## 1) x1   //エラー
```

##include順
- 以下のような`target1.c`
```
#include "h1.h"
#include <h1.h>
```
-`gcc -E ../src/target1.c -I../include`とすると
- ""で囲むとき
  - 処理中のターゲットフォルダ配下 > include配下の順で探しに行く
- <>で囲むとき
  - include配下のみ

- 例えば再帰的にincludeする場合
```
#include "other/h2.h"
```
- `other/h1.h`が読み込まれる
- `other/h1.h`がないとき`include/h1.h`読み込まれる

- まとめると
  - ""は相対パスを優先
  - <>は絶対パスのみ
  
## `#if`ディレクティブで受け付ける条件式はなにか
- 以下で構成された式を受け入れる
  - 整数(12345,0x1,010 ...)
  - bool値(true/false)
  - 四則演算
  - bit演算(&, |, ^, ~)
  - 論理演算(&&, ||, !)
  - 比較(==, !=, >, <, >=, <=)
  - defined文
  - マクロ文
  - かっこ((,))
  
- 整数に論理演算を行った時
  - 0ならfalse, ０以外ならtrueして計算
- bool値にbit演算を行った時
  - falseなら0, trueなら1にして計算
- 文字列、浮動小数はマクロの引数などには使えるが、最終的な評価対象としては使えない
- マクロ定義されていない識別子はfalseになる
  - `#if T` →`#if defined(T)`


##マクロ展開時のトークン分解
- マクロ展開時のトークン分解はマクロ名が識別子であるため、識別子のみで構成されているものとそれ以外を分ける
- 文字列中はトークン分解されない
```
string get_token(string s)
{
  if " から " で終わるのなら
    return s.sub(" から ")
  if 識別子で構成されているなら
    return s.sub(識別子で構成されている範囲)
  rerurn 先頭文字
}
```

## #if 条件式時のトークン分解
- 上記のマクロ展開時のトークン分解に加え、四則演算などを明確に分けなくてはならない。


